/*
 *  GXML/Graphite: Geometry and Graphics Programming Library + Utilities
 *  Copyright (C) 2000 Bruno Levy
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  If you modify this software, you should include a notice giving the
 *  name of the person performing the modification, the date of modification,
 *  and the reason for such modification.
 *
 *  Contact: Bruno Levy
 *
 *     levy@loria.fr
 *
 *     ISA Project
 *     LORIA, INRIA Lorraine, 
 *     Campus Scientifique, BP 239
 *     54506 VANDOEUVRE LES NANCY CEDEX 
 *     FRANCE
 *
 *  Note that the GNU General Public License does not permit incorporating
 *  the Software into proprietary programs. 
 */

#ifndef H_OGF_GOM_REFLECTION_META_H
#define H_OGF_GOM_REFLECTION_META_H

#include <OGF/gom/common/common.h>
#include <OGF/gom/reflection/meta_type.h>
#include <OGF/gom/reflection/meta_class.h>

#include <typeinfo>
#include <string>
#include <map>
#include <vector>

#include <sstream>

//___________________________________________________

/**
 * \file OGF/gom/reflection/meta.h
 * \brief The meta-information used by the reflection API
 */

namespace OGF {

    /**
     * \brief Stores all the meta information of the system,
     *  used by the reflection API.
     * \details The meta information associates to each C++ type
     *  a MetaType object, that implements different services, such
     *  as serialization, introspection and dynamic method invokation,
     *  used to couple Graphite with interpreted languages (python) and
     *  to generate the GUI. The meta information is automatically 
     *  generated by the GOMGEN tool. The meta information can be accessed
     *  either from a string with the type name (as written in C++ sources,
     *  and scoped with OGF::), or with the typeid name (as obtained with
     *  typeid<T>.name).
     */
    class GOM_API Meta {
    public:
        /**
         * \brief destructor fo the Meta database.
         */
        ~Meta() ;

        /**
         * \brief Gets the instance.
         * \return a pointer to the instance of the Meta database.
         */
        static Meta* instance() ;

        /**
         * \brief Tests whether a MetaType exists in the system
         *  by type name.
         * \param[in] name type name
         * \retval true if a type with name \p name exists in the
         *  system
         * \retval false otherwise
         */
        bool meta_type_is_bound(const std::string& name) const ;

        /**
         * \brief Tests whether a MetaType exists in the system
         *  by typeid name.
         * \param[in] typeid_name the C++ RTTI name of the system,
         *  as obtained by typeid<T>.name()
         * \retval true if a type with name \p name exists in the
         *  system
         * \retval false otherwise
         */
        bool typeid_name_is_bound(const std::string& typeid_name) const ;
        
        /**
         * \brief Declares a MetaType to the system
         * \param[in] meta_type a pointer to the MetaType. Ownership
         *  is transfered to Meta.
         */
        bool bind_meta_type(MetaType* meta_type) ;

        /**
         * \brief Declares a MetaType to the system
         * \param[in] meta_type a pointer to the MetaType. Ownership
         *  is transfered to Meta.
         * \param[in] typeid_name the C++ RTTI name of the system,
         *  as obtained by typeid<T>.name()
         */
        bool bind_meta_type(
            MetaType* meta_type, const std::string& typeid_name
        ) ;

        /**
         * \brief Finds a MetaType by type name
         * \param[in] type_name type name
         * \return the MetaType associated with \p type_name if it exists
         *  or nullptr otherwise
         */
        MetaType* resolve_meta_type(const std::string& type_name) const ;

        /**
         * \brief Finds a MetaClass by type name
         * \param[in] type_name type name
         * \return the MetaClass associated with \p type_name if it exists
         *  or nullptr otherwise
         */
        MetaClass* resolve_meta_class(const std::string& type_name) const {
            return dynamic_cast<MetaClass*>(resolve_meta_type(type_name));
        }
        
        /**
         * \brief Finds a MetaType by typeid name
         * \param[in] typeid_name the C++ RTTI name of the system,
         *  as obtained by typeid<T>.name()
         * \return the MetaType associated with \p type_name if it exists
         *  or nullptr otherwise
         */
        MetaType* resolve_meta_type_by_typeid_name(
            const std::string& typeid_name
        ) const ;


        /**
         * \brief Removes a MetaType from the system
         * \param[in] name type name
         * \retval true if the meta type could be sucessfully removed
         * \retval false otherwise
         */
        bool unbind_meta_type(const std::string& name) ;

        /**
         * \brief Gets the list of all MetaType objects declared to the system.
         * \param[out] types a vector of pointers to all the MetaType objects
         */
        void list_types(std::vector<MetaType*>& types) ;

        /**
         * \brief Gets the list of all type names declared to the system.
         * \param[out] type_names a vector of all type names, including aliases.
         */
        void list_type_names(std::vector<std::string>& type_names);
        
        /**
         * \brief Initializes the Meta database
         * \note Does not need to be called by client code, called
         *  at Graphite initialization.
         */
        static void initialize() ;

        /**
         * \brief Terminates the Meta database
         * \note Does not need to be called by client code, called
         *  at Graphite termination.
         */
        static void terminate() ;

    private:
        /**
         * \brief Meta constructor
         * \details Not accessible to client code.
         */
        Meta() ;

        typedef std::map<std::string, MetaType_var> MetaTypesTable ;
        typedef std::map<std::string, MetaType*> TypeidNamesTable ;
  
        static Meta* instance_ ;
        MetaTypesTable   type_name_to_meta_type_ ;
        TypeidNamesTable typeid_name_to_meta_type_ ;
    } ;

    //___________________________________________________________________


    /**
     * \brief Gets the MetaType associated with a variable
     * \details It uses the dynamic type of the variable, e.g.
     *  if a variable is declared as a reference to a base class
     *  and holds a derived class instance, it will get the derived
     *  class.
     * \param[in] x a const reference to the variable
     * \return a pointer to the MetaType of the variable if it 
     *  exists or nullptr otherwise
     */
    template <class T> inline MetaType* ogf_dynamic_type(const T& x) {
        ogf_argused(x); // suppresses a warning of MSVC
        return Meta::instance()->resolve_meta_type_by_typeid_name(
            typeid(x).name() 
        ) ;
    }

    /**
     * \brief Gets the MetaType associated with a variable
     * \details It uses the static type of the variable, i.e.
     *  the C++ type of the variable.
     * \param[in] x a const reference to the variable
     * \return a pointer to the MetaType of the variable if it 
     *  exists or nullptr otherwise
     * \see ogf_dynamic_type
     */
    template <class T> inline MetaType* ogf_static_type(const T& x) {
        ogf_argused(x); // suppresses a warning of MSVC
        return Meta::instance()->resolve_meta_type_by_typeid_name(
            typeid(T).name() 
        ) ;
    }

    /**
     * \brief Tests whether the type of a variable derives from another type.
     * \param[in] x the variable
     * \param[in] type a pointer to the meta type
     * \retval true if the type of \p x derives from \p type
     * \retval false otherwise
     */
    template <class T> inline bool ogf_is_a(const T& x, const MetaType* type) {
        return ogf_dynamic_type(x)->is_a(type) ;
    }

    //___________________________________________________________________

    /**
     * \brief Provides easy access to meta information from C++ types.
     * \tparam T the C++ type to be queried
     */
    template <class T> class ogf_meta {
    public:

        /**
         * \brief Gets the MetaType
         * \return a pointer to the MetaType
         */
        static MetaType* type() {
            static MetaType* result = nullptr ;
            if(result == nullptr) {
                result = Meta::instance()->resolve_meta_type_by_typeid_name(
                    typeid(T).name() 
                ) ;
            }
            if(result == nullptr) {
                Logger::err("Meta") << "No MetaType for typeid "
                                    << typeid(T).name()
                                    << std::endl ;
            }
            ogf_assert(result != nullptr) ;
            return result ;
        }

        /**
         * \brief Gets the MetaClass
         * \details Queries the MetaType and casts it to a MetaClass
         *  if it is a MetaClass, else issues a warning message.
         * \return a pointer to the MetaClass or nullptr if the MetaType
         *  is not a MetaClass
         */
        static MetaClass* meta_class() {
            static MetaClass* result = nullptr ;
            if(result == nullptr) {
                result = dynamic_cast<MetaClass*>(type()) ;
            }
            if(result == nullptr) {
                Logger::err("Meta") << "MetaType for typeid "
                                    << typeid(T).name()
                                    << " is not a MetaClass"
                                    << std::endl ;
            }
            ogf_assert(result != nullptr) ;
            return result ;
        }

        /**
         * \brief Gets the Serializer
         * \details Queries the MetaType and gets the Serializer
         *  associated with it if any, else issues a warning message.
         * \return a pointer to the Serializer or nullptr if none is
         *  available
         */
        static Serializer* serializer() {
            static Serializer* result = type()->serializer() ;
            if(result == nullptr) {
                Logger::err("Meta") << "No Serializer for typeid "
                                    << typeid(T).name()
                                    << std::endl ;
                Logger::err("Meta") << "type name = " << type()->name()
                                    << std::endl ;
            }
            ogf_assert(result != nullptr) ;
            return result ;
        }

        /**
         * \brief Gets the Factory
         * \details MetaType needs to be a MetaClass (i.e. T should be 
         *  a class), else a warning message is issued.
         * \return a pointer to the Serializer or nullptr if none is
         *  available
         */
        static Factory* factory() {
            return meta_class()->factory() ;
        }
    } ;

    //___________________________________________________________________

    /**
     * \brief Converts a variable to a string using the reflection API.
     * \param[in] value a const reference to the variable
     * \param[out] string a reference to the string
     * \retval true if conversion was successful
     * \retval false otherwise
     */
    template <class T> inline bool ogf_convert_to_string(
        const T& value, std::string& string
    ) {
        std::ostringstream stream ;
        bool result = ogf_meta<T>::serializer()->serialize_write(
            stream, (void*)(&value)
        ) ;
        if(result) {
            string = stream.str() ;
        }
        return result ;
    }

    /**
     * \brief Converts a string to a variable using the reflection API.
     * \param[in] string a const reference to the string
     * \param[out] value a reference to the variable
     * \retval true if conversion was successful
     * \retval false otherwise
     */
    template <class T> inline bool ogf_convert_from_string(
        const std::string& string, T& value
    ) {
        if(string.length() == 0) {
            value = T() ;
            return true ;
        }
        std::istringstream stream(string) ;
        return ogf_meta<T>::serializer()->serialize_read(
            stream, (void*)(&value)
        ) ;
    }

    //___________________________________________________________________

}

#endif
