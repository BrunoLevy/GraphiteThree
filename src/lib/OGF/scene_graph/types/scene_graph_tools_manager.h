/*
 *  OGF/Graphite: Geometry and Graphics Programming Library + Utilities
 *  Copyright (C) 2000 Bruno Levy
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  If you modify this software, you should include a notice giving the
 *  name of the person performing the modification, the date of modification,
 *  and the reason for such modification.
 *
 *  Contact: Bruno Levy
 *
 *     levy@loria.fr
 *
 *     ISA Project
 *     LORIA, INRIA Lorraine, 
 *     Campus Scientifique, BP 239
 *     54506 VANDOEUVRE LES NANCY CEDEX 
 *     FRANCE
 *
 *  Note that the GNU General Public License does not permit incorporating
 *  the Software into proprietary programs. 
 */
 
 
#ifndef H_OGF_SCENE_GRAPH_TYPES_SCENE_GRAPH_TOOLS_MGR_H
#define H_OGF_SCENE_GRAPH_TYPES_SCENE_GRAPH_TOOLS_MGR_H

#include <OGF/scene_graph/common/common.h>
#include <OGF/scene_graph/types/scene_graph.h>
#include <OGF/scene_graph/tools/tools_manager.h>
#include <OGF/scene_graph/tools/tool.h>

#include <map>

/**
 * \file OGF/scene_graph/types/scene_graph_tools_manager.h
 * \brief scene graph tools management.
 */

namespace OGF {

    class RenderingContext;


    /**
     * \brief Manages the tools for the entire SceneGraph.
     */
    gom_class SCENE_GRAPH_API SceneGraphToolsManager : public Node {
    public:

        /**
         * \brief SceneGraphToolsManager constructor.
         * \param[in] renderer a pointer to the renderer.
         */
        SceneGraphToolsManager(Node* renderer);

        /**
	 * \brief SceneGraphToolsManager destructor.
	 */
        ~SceneGraphToolsManager() override;
       
       /**
	* \brief Gets the instance.
	* \return a pointer to the SceneGraphToolsManager instance
	*/
        static SceneGraphToolsManager* instance() {
	   return instance_;
	}

	/**
	 * \brief Gets the SceneGraph.
	 * \return a pointer to the SceneGraph.
	 */
	SceneGraph* scene_graph() {
	    return scene_graph_;
	}

	
    gom_slots:
        /**
         * \brief Notify the SceneGraphToolsManager that the current 
         *  focus matrix changed.
         * \param[in] value the current focus matrix.
         */
        void focus(const mat4& value);

        /**
         * \brief Notify this SceneGraphToolsManager that the 
         *  current object changed.
         * \param[in] value name of the new current object
         */
        void current_object(const std::string& value);

        /**
         * \brief Changes the current tool.
         * \param[in] value the class name of the tool, with 
         *  "OGF::" prefix
         */
        void tool(const std::string& value);

        /**
         * \brief Called when a mouse button is pressed.
         * \param[in] value the RayPick generated by the RayPicker from
         *  the mouse event
         */
        void grab(const RayPick& value);

        /**
         * \brief Called when the mouse is dragged with a button pressed.
         * \param[in] value the RayPick generated by the RayPicker from
         *  the mouse event
         */
        void drag(const RayPick& value);

        /**
         * \brief Called when a mouse button is released.
         * \param[in] value the RayPick generated by the RayPicker from
         *  the mouse event
         */
        void release(const RayPick& value);

        /**
         * \brief Gets the current Tool.
         * \return a pointer to the current Tool
         */
        Tool* current() const;

        /**
         * \brief Gets the current ToolsManager.
         * \return a pointer to the current ToolsManager (associated with the
         *  class of the current object)
         */
        ToolsManager* current_tools_manager() const;

    gom_signals:
        /**
         * \brief A signal that is triggered by the tools to display status
         *  messages in the status bar.
         */
        void status_message(const std::string& value);

        /**
         * \brief A signal that is triggered each time the current tool changes,
         *  to update the tool icon in the status bar.
         * \param[in] value the name of the tool icon, relative to 
         *  lib/icons/tools
         */
        void tool_icon_changed(const std::string& value);

      gom_slots:
        /**
         * \brief Triggers the tool_icon_changed() signal.
         * \param[in] value the name of the tool icon, relative to 
         *  lib/icons/tools
         */
        void update_tool_icon(const std::string& value);

        /**
         * \brief Gets the focus matrix
         * \return the focus matrix
         */
        const mat4& get_focus() const {
            return focus_;
        }

        /**
         * \brief Gets the renderer
         * \return a pointer to the rendering window
         */
        Node* renderer() const {
            ogf_assert(renderer_ != nullptr);
            return renderer_;
        }

        /**
         * \brief Sets the RenderingContext
         * \param[in] rendering_context a pointer to the RenderingContext
         */
        void set_rendering_context( OGF::RenderingContext* rendering_context );
        

        /**
         * \brief Gets the RenderingContext
         * \return a pointer to the RenderingContext
         */
        RenderingContext* rendering_context();

        /**
         * \brief Triggers the status_message() signal.
         * \param[in] value the message to be displayed
         */
        void status(const std::string& value) {
            status_message(value);
        }

    protected:
        /**
         * \brief Finds a ToolManager by Grob class name.
         * \param[in] grob_class_name the Grob class name as
         *  a string, with the "OGF::" prefix
         * \return a pointer to the ToolsManager
         */
        ToolsManager* resolve_tools_manager(
            const std::string& grob_class_name
        );

        /**
         * \brief Creates the GUI for the tools.
         */
        void create_gui();

    private:
        SceneGraph* scene_graph_;
        Node* renderer_;
        ToolsManager* current_tools_manager_;
        RenderingContext* rendering_context_;
        typedef std::map<std::string, ToolsManager_var> ToolsMap;
        ToolsMap tools_;
        mat4 focus_;
        static SceneGraphToolsManager* instance_;
    };
}

#endif
