/*
 *  OGF/Graphite: Geometry and Graphics Programming Library + Utilities
 *  Copyright (C) 2000 Bruno Levy
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  If you modify this software, you should include a notice giving the
 *  name of the person performing the modification, the date of modification,
 *  and the reason for such modification.
 *
 *  Contact: Bruno Levy
 *
 *     levy@loria.fr
 *
 *     ISA Project
 *     LORIA, INRIA Lorraine, 
 *     Campus Scientifique, BP 239
 *     54506 VANDOEUVRE LES NANCY CEDEX 
 *     FRANCE
 *
 *  Note that the GNU General Public License does not permit incorporating
 *  the Software into proprietary programs. 
 */

#ifndef H_OGF_SCENE_GRAPH_TYPES_COMMANDS_H
#define H_OGF_SCENE_GRAPH_TYPES_COMMANDS_H

#include <OGF/scene_graph/common/common.h>
#include <OGF/scene_graph/types/properties.h>
#include <OGF/gom/types/node.h>

/**
 * \file OGF/scene_graph/commands/commands.h
 * \brief class that gathers commands with menu and
 *  dialogs.
 */

namespace OGF {

    class Grob;
    class SceneGraph;

    /**
     * \brief Represents additional functions that can be
     *  attached to an object.
     * \details Interface objects registered from a Grob class
     *  can be accessed by calling Object::query_interface().
     *  Interface is like Commands, but the system does not 
     *  generate any menus for them. Interface can be scripted though.
     * \note To be taken into account by the system, a 
     *  Commands object has to satisfy the following 
     *  requirements:
     *  - it is a gom_class derived from the Interface class
     *  - its functions are declared as gom_slot
     *  - it is declared in the initializer of the package using
     *   ogf_register_grob_interface. See OGF/mesh/common/mesh_common.cpp
     *   for an example.
     */
    gom_attribute(abstract, "true")
    gom_class SCENE_GRAPH_API Interface : public Object {
      public:
	/**
	 * \brief Interface constructor.
	 */
	Interface();

	/**
	 * \brief Interface destructor.
	 */
	~Interface() override;
	
        /**
         * \brief Gets the Grob.
         * \return a pointer to the Grob this Commands
         *  is associated with
         */
        Grob* grob() const {
            return grob_;
        }

        /**
         * \brief Gets the SceneGraph.
         * \details shorthand for
         *  grob()->scene_graph()
         * \return a pointer to the SceneGraph this
         *  Commands is associated with 
         */
        SceneGraph* scene_graph() const;

    gom_properties:
        
        /**
         * \brief Sets the current Grob
         * \param[in] value a pointer to the Grob
         */
        virtual void set_grob(Grob* value);

        /**
         * \brief Gets the current Grob
         * \return a pointer to the current Grob
         */
        Grob* get_grob() const {
            return grob_;
        }

    private:
        Grob* grob_;
    };

    typedef SmartPointer<Interface> Interface_var;
    
    /****************************************************/
    
    /**
     * \brief Represents a set of commands.
     * \details Each member function declared as
     *  gom_slot will have a menun entry and a 
     *  dialog, generated by AutoGUI.
     *  The Doxygen comments associated with each
     *  member function are interpreted by AutoGUI,
     *  the "brief" tag and the "param" tag are interpreted
     *  to generate tooltips. In addition, the following tags
     *  can be used:
     *  - "menu": indicate a menu relative to current menu,
     *   or an absolute menu (starting
     *   with a '/') to insert the command in existing
     *   menus (for instance /Surface/Remesh)
     *  - "advanced" all subsequent parameters are in the
     *   advanced section of the command (displayed when
     *   clicking on it)
     * \note To be taken into account by the system, a 
     *  Commands object has to satisfy the following 
     *  requirements:
     *  - it is a gom_class derived from the Commands class
     *  - its functions are declared as gom_slot
     *  - it is declared in the initializer of the package using
     *   ogf_register_grob_commands. See OGF/mesh/common/mesh_common.cpp
     *   for an example.
     *  When using the "devel" plugin, a skeleton that satisfies these
     *  requirements is automatically created.
     */
    gom_attribute(abstract, "true")
    gom_class SCENE_GRAPH_API Commands : public Interface {
    public:
        /**
         * \brief Commands constructor.
         */
        Commands();

        /**
         * \brief Commands destructor.
         */
        ~Commands() override;


        /**
         * \copydoc Object::invoke_method
         * \details Overload of the invokation mechanism,
         *  that adds timings and history recording.
         */
        bool invoke_method(
            const std::string& method_name,
            const ArgList& args, Any& ret_val
        ) override;

	/**
	 * \brief Gets the main Interpreter.
	 * \return a pointer to the main Interpreter.
	 */
	Interpreter* interpreter();

      gom_properties:

	/**
	 * \brief Tests whether timings are reported.
	 * \retval true if timings are reported.
	 * \retval false otherwise.
	 */
	bool get_chrono() const {
	    return chrono_;
	}

	/**
	 * \brief Sets whether timings are reported.
	 * \param[in] value true if timings should be reported,
	 *  false otherwise.
	 */
	void set_chrono(bool value) {
	    chrono_ = value;
	}

      public:

	/**
	 * \brief Tests whether a command is currently running.
	 * \retval true if a command is currently running.
	 * \retval false otherwise.
	 */
	static bool command_is_running() {
	    return command_is_running_;
	}
	
      private:
	bool chrono_;
	static bool command_is_running_;
    };

    typedef SmartPointer<Commands> Commands_var;
}

#endif
